<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Skyward Blob v1.8.0</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0;
      height: 100%;
      background: #0b1020;
      overflow: hidden;
      font-family: ui-rounded, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Noto Sans";
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none;
      cursor: none;
    }
    .tiny {
      position: fixed;
      inset: 0;
      pointer-events: none;
      display: grid;
      place-items: end center;
      padding: 10px;
      font-size: 12px;
      color: #9fb5ff;
      opacity: .65;
      user-select: none;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="tiny">Skyward Blob v1.8.0</div>

  <script>
  /* Skyward Blob v1.8.0
     ‚Ä¢ Slime platforms (rare, on NORMAL only): fixed hue; landing paints the blob to that hue and grows it a bit (capped).
       Shield trigger resets blob SIZE back to base (color stays).
     ‚Ä¢ Size ‚Üí Jump scaling: Bigger blob jumps lower. At max size (150), upward velocity is clamped to MIN_JUMP_SCALE (default 0.50).
     ‚Ä¢ Auto-shield: shield pickups become charges immediately; no manual use.
     ‚Ä¢ Controls: A/D or ‚óÄ ‚ñ∂ to move; ‚ñº = Ground Pound (üí•); ‚ñ≤ = Jetpack (üöÄ). Enter only restarts when game over.
     ‚Ä¢ Ground Pound: breaks through CRUMBLE only (no bounce); next non-crumble bounce is +50%; trail + ‚ÄúSHING‚Äù SFX.
     ‚Ä¢ Power-up icons ~2√ó.
  */

  // ‚Äî‚Äî‚Äî Tunables ‚Äî‚Äî‚Äî
  const SLIME_SPAWN_CHANCE = 0.035;        // 3.5% of NORMAL platforms spawn with slime
  const SLIME_GROWTH       = 4;            // radius growth per slime landing
  const BASE_R             = 28;           // base blob radius
  const MAX_R              = 150;          // max blob radius
  const MIN_JUMP_SCALE     = 0.50;         // upward velocity floor at MAX_R (height ‚âà 25% when 0.50)
  
  const RAINBOW_SWIZZLE_DEG_PER_SEC = 540; // ~1.5 rotations/sec (360 = 1 rotation/sec)

  // ‚Äî‚Äî‚Äî Sound effects (jump/spring from small files; others procedural) ‚Äî‚Äî‚Äî
  const jumpSound   = new Audio('https://cdn.freesound.org/previews/159/159376_2874984-lq.mp3');
  const springSound = new Audio('https://cdn.freesound.org/previews/159/159377_2874984-lq.mp3');
  [jumpSound, springSound].forEach(a => { a.preload = "auto"; a.crossOrigin = "anonymous"; a.volume = 0.75; });

  // WebAudio core
  let AC = null;
  function getAC(){ if (!AC) AC = new (window.AudioContext||window.webkitAudioContext)(); return AC; }
  let audioReady = false, muted = false;
  function unlockAudio(){ if (audioReady) return; audioReady = true; try { jumpSound.play().then(()=>jumpSound.pause()).catch(()=>{}); } catch(e){} getAC().resume(); }
  function envGain(ac, t0, dur, a0, a1){ const g = ac.createGain(); g.gain.setValueAtTime(a0, t0); g.gain.exponentialRampToValueAtTime(Math.max(0.0001,a1), t0+dur); return g; }
  function playSfxTag(tag, vol=1, rateMin=0.97, rateMax=1.04){
    if (muted || !audioReady) return;
    try { const a = tag.cloneNode(true); a.volume = Math.max(0, Math.min(1, vol)); a.playbackRate = rateMin + Math.random()*(rateMax-rateMin); a.play().catch(()=>{}); } catch(e){}
  }

  // Procedural SFX
  function playGrossFX(){ // shield-save splat
    if (muted || !audioReady) return;
    const ac = getAC(); const now = ac.currentTime;
    const src = ac.createBufferSource();
    const len = ac.sampleRate * 0.38, buf = ac.createBuffer(1, len, ac.sampleRate), d = buf.getChannelData(0);
    for (let i=0;i<len;i++){ const t=i/len; d[i]=(Math.random()*2-1)*Math.pow(1-t,0.4)*(0.6+0.4*Math.sin(i*0.02)); }
    src.buffer = buf;
    const lpf = ac.createBiquadFilter(); lpf.type='lowpass'; lpf.frequency.setValueAtTime(800, now); lpf.Q.value=0.5;
    const dist = ac.createWaveShaper(); dist.curve = new Float32Array(257).map((_,i)=>{ const x=i/128-1; return Math.tanh(2.2*x); });
    const g = envGain(ac, now, 0.38, 0.95, 0.0001);
    src.connect(lpf).connect(dist).connect(g).connect(ac.destination);
    src.start(now); src.stop(now+0.38);
  }
  function playWahWahFX(){ // comedic death wah-wah
    if (muted || !audioReady) return;
    const ac = getAC(); const now = ac.currentTime;
    const osc = ac.createOscillator(); osc.type='sawtooth';
    const vbr = ac.createOscillator(); vbr.type='sine'; vbr.frequency.value = 6.5;
    const vgain = ac.createGain(); vgain.gain.value = 20;
    vbr.connect(vgain).connect(osc.frequency);
    osc.frequency.setValueAtTime(330, now);
    osc.frequency.exponentialRampToValueAtTime(150, now+0.55);
    const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=400; bp.Q.value=2.5;
    const g = envGain(ac, now, 0.6, 0.9, 0.0001);
    osc.connect(bp).connect(g).connect(ac.destination);
    vbr.start(now); osc.start(now);
    vbr.stop(now+0.6); osc.stop(now+0.6);
  }
  function playPickupFX(){ // friendly pickup bleep
    if (muted || !audioReady) return;
    const ac = getAC(); const now = ac.currentTime;
    const o = ac.createOscillator(); o.type='triangle';
    o.frequency.setValueAtTime(660, now); o.frequency.linearRampToValueAtTime(990, now+0.12);
    const g = envGain(ac, now, 0.18, 0.8, 0.0001); o.connect(g).connect(ac.destination);
    o.start(now); o.stop(now+0.18);
  }
  function playUseFX(){ // using item (rocket)
    if (muted || !audioReady) return;
    const ac = getAC(); const now = ac.currentTime;
    const o = ac.createOscillator(); o.type='square';
    o.frequency.setValueAtTime(440, now); o.frequency.linearRampToValueAtTime(330, now+0.1);
    const g = envGain(ac, now, 0.2, 0.6, 0.0001); o.connect(g).connect(ac.destination);
    o.start(now); o.stop(now+0.2);
  }
  function playRainbowFX(){ // rainbow whoosh + sparkle
    if (muted || !audioReady) return;
    const ac = getAC(); const now = ac.currentTime;
    const nsrc = ac.createBufferSource();
    const nlen = ac.sampleRate * 0.4, nbuf = ac.createBuffer(1, nlen, ac.sampleRate), nd = nbuf.getChannelData(0);
    for (let i=0;i<nlen;i++){ const t=i/nlen; nd[i]=(Math.random()*2-1)*Math.pow(1-t,0.6); }
    nsrc.buffer = nbuf;
    const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=900; bp.Q.value=0.8;
    const ng = envGain(ac, now, 0.4, 0.001, 0.6);
    const tone = (f,t0,dur)=>{ const o=ac.createOscillator(); o.type='triangle'; const g=envGain(ac,t0,dur,0.7,0.0001); o.frequency.setValueAtTime(f,t0); o.connect(g).connect(ac.destination); o.start(t0); o.stop(t0+dur); };
    tone(880, now+0.02, 0.18); tone(1175, now+0.09, 0.16);
    nsrc.connect(bp).connect(ng).connect(ac.destination);
    nsrc.start(now); nsrc.stop(now+0.4);
  }
  function playShingFX(){ // ground pound ‚ÄúSHING‚Äù
    if (muted || !audioReady) return;
    const ac = getAC(); const now = ac.currentTime;
    const o1 = ac.createOscillator(); o1.type='sawtooth';
    const o2 = ac.createOscillator(); o2.type='square'; o2.detune.value = +8;
    o1.frequency.setValueAtTime(320, now); o1.frequency.exponentialRampToValueAtTime(1700, now+0.12);
    o2.frequency.setValueAtTime(300, now); o2.frequency.exponentialRampToValueAtTime(1500, now+0.12);
    const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1400; bp.Q.value=6;
    const g = envGain(ac, now, 0.16, 0.9, 0.0001);
    const nsrc = ac.createBufferSource();
    const len = ac.sampleRate * 0.12, buf = ac.createBuffer(1, len, ac.sampleRate), d = buf.getChannelData(0);
    for (let i=0;i<len;i++){ const t=i/len; d[i]=(Math.random()*2-1)*Math.pow(1-t,0.2); }
    const hp = ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1800; hp.Q.value=0.7;
    const ng = envGain(ac, now, 0.12, 0.6, 0.0001);
    o1.connect(bp); o2.connect(bp); bp.connect(g).connect(ac.destination);
    nsrc.buffer = buf; nsrc.connect(hp).connect(ng).connect(ac.destination);
    o1.start(now); o2.start(now); nsrc.start(now);
    o1.stop(now+0.16); o2.stop(now+0.16); nsrc.stop(now+0.12);
  }
  function playSplatFX(){ // slime squishy-splat
    if (muted || !audioReady) return;
    const ac = getAC(); const now = ac.currentTime;
    const n = ac.createBufferSource();
    const len = ac.sampleRate * 0.22, buf = ac.createBuffer(1, len, ac.sampleRate), d = buf.getChannelData(0);
    for (let i=0;i<len;i++){ const t=i/len; const wob = Math.sin(i*0.025)*0.4; d[i]=(Math.random()*2-1)*(0.9-wob)*Math.pow(1-t,0.25); }
    const bp = ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=320; bp.Q.value=0.7;
    const g  = envGain(ac, now, 0.22, 0.9, 0.0001);
    n.buffer = buf; n.connect(bp).connect(g).connect(ac.destination); n.start(now); n.stop(now+0.22);
  }

  // ‚Äî‚Äî‚Äî Canvas / DPI ‚Äî‚Äî‚Äî
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function resize(){ DPR=Math.max(1, Math.min(2, window.devicePixelRatio||1)); canvas.width=Math.floor(innerWidth*DPR); canvas.height=Math.floor(innerHeight*DPR); }
  addEventListener('resize', resize, {passive:true}); resize();

  // ‚Äî‚Äî‚Äî Helpers ‚Äî‚Äî‚Äî
  const TAU = Math.PI*2;
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const rand=(a=1,b=null)=>b==null?Math.random()*a:a+Math.random()*(b-a);
  const randi=(a,b)=>Math.floor(rand(a,b));
  const sign=v=>v<0?-1:1;
  function easeOutBack(t){ const c1=1.70158,c3=c1+1; return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2); }
  function sizeJumpScale(){ const t = clamp((player.r - BASE_R) / (MAX_R - BASE_R), 0, 1); return lerp(1, MIN_JUMP_SCALE, t); }
  let rainbowHueOffset = 0;


  // ‚Äî‚Äî‚Äî Input ‚Äî‚Äî‚Äî
  const keys = { left:false, right:false };
  let paused=false, showInfo=false;
  addEventListener('keydown', (e)=>{
    unlockAudio();
    if (e.repeat) return;
    if (e.code==='KeyA' || e.code==='ArrowLeft')  keys.left = true;
    if (e.code==='KeyD' || e.code==='ArrowRight') keys.right = true;
    if (e.code==='KeyM') muted = !muted;
    if (e.code==='KeyP') paused = !paused;
    if (e.code==='KeyI') showInfo = !showInfo;
    // Restart only when dead
    if ((e.code==='Enter' || e.code==='NumpadEnter') && gameState === STATE.DEAD) { e.preventDefault(); resetGame(); }

    // Use items: ‚ñº = ground pound; ‚ñ≤ = rocket; (shield is auto)
    if (e.code==='ArrowDown' || e.code==='Digit1') useFixedSlot('ground');
    if (e.code==='ArrowUp'   || e.code==='Digit2') useFixedSlot('jetpack');
  });
  addEventListener('keyup', (e)=>{
    if (e.code==='KeyA' || e.code==='ArrowLeft')  keys.left=false;
    if (e.code==='KeyD' || e.code==='ArrowRight') keys.right=false;
  });
  function touchMoveToKeys(x){ const half = canvas.width/2; keys.left = x<half; keys.right = x>=half; }
  canvas.addEventListener('pointerdown', e=>{ unlockAudio(); canvas.setPointerCapture(e.pointerId); touchMoveToKeys(e.clientX*DPR); });
  canvas.addEventListener('pointermove', e=>{ if (e.pressure>0) touchMoveToKeys(e.clientX*DPR); });
  canvas.addEventListener('pointerup', ()=>{ keys.left=false; keys.right=false; });

  // ‚Äî‚Äî‚Äî World / State ‚Äî‚Äî‚Äî
  const STATE = { RUN:0, DEAD:1 };
  let gameState = STATE.RUN;

  const world = {
    gravity: 2200,
    maxSpeed: 700,
    jumpVel: 1600,
    springVel: 2200,
    cameraY: 0,
    shake: 0,
    timeScale: 1,
    width: ()=>canvas.width,
    height:()=>canvas.height,
  };

  const player = {
    x:0, y:0, vx:0, vy:0,
    r:BASE_R,
    trail:[],
    wobble:0,
    color:{h:215,s:85,l:62},
    combo:0,
    comboTimer:0,
    // Effects
    jetpackT:0,       // standard rocket jet
    rainbowT:0,       // rainbow sustained jet
    fallSlowT:0,      // cloud effect timer (2.0s: 1s full + 1s taper)
    shield:0,         // auto-use charges
    // Ground Pound
    poundActive:false,
    poundBuffPending:false,
    poundTrailT:0
  };

  // ‚Äî‚Äî‚Äî Fixed inventory (manual-use items only) ‚Äî‚Äî‚Äî
  const fixedInv = { ground:false, jetpack:0 }; const MAX_ROCKETS = 3;

  function pickUpPower(type){
    if (type==='jetpack'){ if (fixedInv.jetpack < MAX_ROCKETS){ fixedInv.jetpack++; playPickupFX(); } return; }
    if (type==='ground'){ if (!fixedInv.ground){ fixedInv.ground = true; playPickupFX(); } return; }
    if (type==='shield'){ // auto-shield: becomes a charge immediately
      player.shield = Math.min(2, player.shield + 1); playPickupFX(); return;
    }
    if (type==='cursed'){ if (player.shield>0){ player.shield = Math.max(0, player.shield-1); world.shake=5; playGrossFX(); } return; }
  }

  function useFixedSlot(type){
    if (gameState!==STATE.RUN) return;
    let used=false;
    if (type==='jetpack' && fixedInv.jetpack>0){
      fixedInv.jetpack--; used=true; player.jetpackT=0.75; world.shake=4; player.vy = -world.springVel*1.2*sizeJumpScale(); playUseFX();
    }
    if (type==='ground' && fixedInv.ground){
      fixedInv.ground=false; used=true;
      player.jetpackT = 0; player.rainbowT = 0;
      player.poundActive = true;
      player.poundBuffPending = true;
      player.poundTrailT = 2.8;
      player.vy = Math.max(player.vy, world.springVel*1.0); // force decisive downward
      world.shake = 5; playShingFX();
    }
  }

  // Stars parallax
  const stars = (()=>{ const arr=[]; for(let i=0;i<3;i++){ const layer=[]; for(let j=0;j<(i+1)*40;j++) layer.push({x:Math.random(),y:Math.random(),size:1+i,speed:0.15+i*0.15,hue:210+i*10}); arr.push(layer);} return arr; })();

  // Platforms + Clouds
  const platforms = [];  let lastPlatY = 0;
  const clouds = [];     // non-platform slow fields

  // Particles
  const particles = [];

  // Score/Progress
  let startY = 0, peakY = 0, maxAscend = 0;
  function metersFromPixels(px){ return Math.floor(px / (10*DPR)); }
  let best = Number(localStorage.getItem('sb_v12_high') || 0);

  // Width curve: ~200px at start ‚Üí 100px @ 7,500m ‚Üí 90px @ 10,000m
  function platformWidthForMeters(m){
    if (m <= 7500) return lerp(200*DPR, 100*DPR, m/7500);
    const t = clamp((m-7500)/2500, 0, 1);
    return lerp(100*DPR, 90*DPR, t);
  }

  // ‚Äî‚Äî‚Äî Platform generation ‚Äî‚Äî‚Äî
  function makePlatform(y){
    const W = world.width(), margin = 60*DPR;
    const x = rand(margin, W - margin);

    const m = metersFromPixels(maxAscend);
    const baseWidth = platformWidthForMeters(m);
    const width = rand(baseWidth*0.85, baseWidth*1.15);

    // Weights ‚Äî booster & rainbow rarer across the board
    const tSpring  = lerp(0.08, 0.12, clamp(maxAscend/6000,0,1));
    const tCrumble = lerp(0.05, 0.16, clamp(maxAscend/7000,0,1));
    const tMove    = lerp(0.07, 0.16, clamp(maxAscend/7000,0,1));
    const tBooster = lerp(0.0025, 0.010, clamp(maxAscend/8000,0,1)); // rarer
    const tRainbow = lerp(0.0000, 0.0025, clamp(maxAscend/8000,0,1)); // very rare

    let r = Math.random(), acc = 0, type='normal';
    if      ((acc+=tSpring)  > r) type='spring';
    else if ((acc+=tCrumble) > r) type='crumble';
    else if ((acc+=tMove)    > r) type='move';
    else if ((acc+=tBooster) > r) type='booster';
    else if ((acc+=tRainbow) > r) type='rainbow';

    // Per-type speed (purple = 2√ó faster)
    let speed = rand(60,120)*DPR;
    if (type==='move') speed *= 2;

    // Power-up spawn chance (independent of type)
    const powerChance = lerp(0.10, 0.18, clamp(maxAscend/6000, 0, 1));
    let power = null;
    if (Math.random() < powerChance){
      const pick = Math.random();
      power = pick < 0.40 ? 'jetpack' : pick < 0.575 ? 'ground' : pick < 0.95 ? 'shield' : 'cursed';
    }

    // Slime flag (RARE; ONLY on normal)
    const hasSlime = (type==='normal' && Math.random() < SLIME_SPAWN_CHANCE);
    const slimeHue = hasSlime ? randi(0, 360) : 0;

    return { x, y, width, height:16*DPR, type, dir: Math.random()<0.5?-1:1, speed, hit:false, life:1, power, hasSlime, slimeHue };
  }

  function makeCloud(y){
    const W = world.width(), margin = 80*DPR;
    const x = rand(margin, W - margin);
    const w = rand(140*DPR, 220*DPR), h = rand(26*DPR, 40*DPR);
    return { x, y, w, h, life:1, hit:false };
  }

  function populateUpTo(targetY){
    const gapMinBase = 110*DPR, gapMaxBase = 200*DPR;
    const gapMin = gapMinBase * 0.8, gapMax = gapMaxBase * 0.8;
    while (lastPlatY > targetY){
      const gap = lerp(gapMax, gapMin, clamp(maxAscend/7000, 0, 1));
      lastPlatY -= rand(gap*0.85, gap*1.15);

      platforms.push(makePlatform(lastPlatY));

      const cloudChance = lerp(0.02, 0.10, clamp(maxAscend/7000, 0, 1));
      if (Math.random() < cloudChance){
        clouds.push(makeCloud(lastPlatY - rand(40*DPR, 120*DPR)));
      }
    }
  }
  function clearLowStuff(){
    const bottom = world.cameraY + world.height() + 120*DPR;
    for (let i=platforms.length-1;i>=0;i--) if (platforms[i].y > bottom) platforms.splice(i,1);
    for (let i=clouds.length-1;i>=0;i--) if (clouds[i].y > bottom || clouds[i].life<=0) clouds.splice(i,1);
  }

  // Particles
  function cloudPuffs(x, y){
    for (let i = 0; i < 12; i++){
      particles.push({
        x: x + rand(-30, 30) * DPR,
        y: y + rand(-8, 8) * DPR,
        vx: rand(-40, 40),
        vy: rand(-20, 20),
        life: 1,
        decay: rand(0.008, 0.02),
        size: rand(2 * DPR, 4 * DPR),
        hue: 210 + rand(-10, 10)
      });
    }
  }
  function burst(x,y,base=16,count=18,hue=200){
    for (let i=0;i<count;i++){
      particles.push({ x,y, vx:(Math.random()-0.5)*base*rand(10,35), vy:(Math.random()-0.5)*base*rand(10,35),
        life:1, decay:rand(0.012,0.03), size:rand(2*DPR,5*DPR), hue:hue+rand(-10,10) });
    }
  }
  function puff(x,y,dir=1,hue=200){
    for (let i=0;i<8;i++){
      particles.push({ x:x+rand(-6,6)*DPR, y:y+rand(-2,6)*DPR, vx:rand(30,120)*DPR*dir*(Math.random()*0.6+0.4),
        vy:rand(-40,40)*DPR, life:1, decay:rand(0.02,0.035), size:rand(3*DPR,7*DPR), hue });
    }
  }
  function rainbowEngineParticles(px, py){
    for (let i=0;i<8;i++){
      const vx = rand(-260, 260);
      const vy = rand(40, 140);
      particles.push({
        x: px + rand(-4,4)*DPR,
        y: py + player.r*0.9,
        vx, vy,
        life: 1,
        decay: rand(0.025,0.045),
        size: rand(2*DPR,4*DPR),
        hue: randi(0, 360)
      });
    }
  }
  function poundTrailParticles(px, py){
    for (let i=0;i<8;i++){
      particles.push({
        x: px + rand(-6,6)*DPR,
        y: py + rand(-6,6)*DPR,
        vx: rand(-120,120),
        vy: rand(80,200),
        life: 1,
        decay: rand(0.02, 0.045),
        size: rand(2*DPR, 4*DPR),
        hue: 195 + rand(-8, 8)
      });
    }
    if (Math.random() < 0.15){ burst(px, py+player.r*0.6, 6, 8, 200); }
  }

  // Reset
  function resetGame(){
    gameState = STATE.RUN; paused=false; showInfo=false;
    world.cameraY=0; world.shake=0; world.timeScale=1;
    platforms.length=0; particles.length=0; clouds.length=0;
    fixedInv.ground=false; fixedInv.jetpack=0;
    player.x = canvas.width/2; player.y = canvas.height*0.5; player.vx=0; player.vy=-400;
    player.trail=[]; player.wobble=0; player.combo=0; player.comboTimer=0;
    player.jetpackT=0; player.rainbowT=0; player.fallSlowT=0; player.shield=0;
    player.poundActive=false; player.poundBuffPending=false; player.poundTrailT=0;
    player.r = BASE_R; player.color = {h:215,s:85,l:62};

    startY = player.y; peakY = player.y; maxAscend = 0;

    lastPlatY = player.y + 60*DPR;
    platforms.push({ x:canvas.width/2, y:player.y + 120*DPR, width:280*DPR, height:18*DPR, type:'normal', dir:0, speed:0, hit:false, life:1, power:null, hasSlime:false, slimeHue:0 });
    populateUpTo(world.cameraY - canvas.height*1.2);
  }
  resetGame();

  // Collisions
  function collidePlatforms(prevY){
    if (player.vy <= 0) return; // only interact when falling
    const px=player.x, py=player.y, pr=player.r;
    const top = world.cameraY - 20*DPR, bottom = world.cameraY + world.height() + 20*DPR;

    for (let i=0;i<platforms.length;i++){
      const p = platforms[i];
      if (p.y + p.height < top || p.y - pr > bottom) continue;

      const half = p.width/2;
      const withinX = (px > p.x - half - pr*0.8) && (px < p.x + half + pr*0.8);
      const crossing = (prevY + pr <= p.y) && (py + pr >= p.y - 2*DPR);

      if (withinX && crossing){

        // Ground Pound: break only CRUMBLE, fall through; otherwise land normally
        if (player.poundActive){
          if (p.type === 'crumble'){
            world.shake += 7;
            burst(p.x, p.y-2*DPR, 14, 26, 180);
            p.y = world.cameraY + world.height() + 1000; // remove it
            player.poundActive = false; // keep buff pending
            return; // keep falling; no bounce
          } else {
            player.poundActive = false; // stop pounding; proceed to normal land
          }
        }

        // land! (normal behavior)
        player.y = p.y - pr;
        const centerDelta = Math.abs(px - p.x);
        const perfect = centerDelta < p.width*0.18;

        let boost = world.jumpVel;
        let sfx = jumpSound;
        let hueBurst = 160;
        const sizeScale  = sizeJumpScale();
        const poundBoost = player.poundBuffPending ? 1.5 : 1;

        if (p.type==='spring'){
          boost = world.springVel; sfx = springSound; burst(p.x, p.y-2*DPR, 14, 22, 120);
        } else if (p.type==='booster'){
          boost = world.springVel * 1.5; hueBurst = 110; world.shake += 1.1;
          burst(p.x, p.y-2*DPR, 16, 26, 110);
        } else if (p.type==='rainbow'){
          // Sustained thrust ‚Äî initial kick can be boosted; sustained part handled in update()
          player.rainbowT = 1.10;
          player.vy = -world.springVel * 1.35 * poundBoost * sizeScale;
          world.shake += 1.3;
          burst(p.x, p.y-2*DPR, 18, 28, 0);
          playRainbowFX();
        } else {
          puff(px, p.y, sign(player.vx||1), 200);
        }

        // SLIME effect: ONLY on normal platforms that spawned with slime
        if (p.hasSlime && p.type==='normal'){
          player.color.h = p.slimeHue;                          // repaint blob
          player.r = Math.min(MAX_R, player.r + SLIME_GROWTH);  // grow (capped)
          playSplatFX();
          burst(p.x, p.y-2*DPR, 10, 16, p.slimeHue);
        }

        if (p.type==='crumble'){ p.life = Math.max(0, p.life - 1); p.hit = true; }
        if (p.type==='move'){ player.x += p.dir * p.speed * 0.06; } // slight carry

        if (perfect){
          player.combo = Math.min(9, player.combo + 1);
          player.comboTimer = 1.2;
          boost *= 1.04 + player.combo*0.01;
          world.shake += 0.6 + player.combo*0.08;
          burst(px, p.y-2*DPR, 10, 12, hueBurst);
        } else {
          player.combo = Math.max(0, player.combo - 0.5);
        }

        if (p.type!=='rainbow'){
          player.vy = -boost * poundBoost * sizeScale;
        }
        if (player.poundBuffPending) player.poundBuffPending = false;

        player.wobble = 1;

        if (p.power){ pickUpPower(p.power); p.power = null; }

        if (p.type==='spring') playSfxTag(springSound, 0.9, 0.98, 1.05);
        else playSfxTag(jumpSound, 0.85, 0.98, 1.05);

        return;
      }
    }
  }

  // Cloud slow fields ‚Äî no bounce; strong slow + taper
  function collideClouds(prevY){
    if (player.vy <= 0) return;
    const px=player.x, py=player.y, pr=player.r;
    const top = world.cameraY - 40*DPR, bottom = world.cameraY + world.height() + 40*DPR;

    for (const c of clouds){
      if (c.y + c.h < top || c.y - pr > bottom) continue;
      const half = c.w/2;
      const withinX = (px > c.x - half - pr*0.7) && (px < c.x + half + pr*0.7);
      const crossing = (prevY + pr <= c.y) && (py + pr >= c.y - 2*DPR);
      if (withinX && crossing){
        player.fallSlowT = 2.0;    // 1s full + 1s taper
        player.vy *= 0.25;         // instant vertical speed cut to 25%
        cloudPuffs(c.x, c.y);
        c.life = 0; // dissolve after use
      }
    }
  }

  // ‚Äî‚Äî‚Äî Update ‚Äî‚Äî‚Äî
  let lastT = performance.now();
  function update(dtReal){
    if (paused || gameState !== STATE.RUN) return;

    const dt = dtReal * world.timeScale;

    // Horizontal control
    if (keys.left && !keys.right)      player.vx = -world.maxSpeed;
    else if (!keys.left && keys.right) player.vx =  world.maxSpeed;
    else                               player.vx =  0;

    // Jets (size-scaled)
    if (player.jetpackT > 0){
      player.jetpackT -= dt;
      const s = sizeJumpScale();
      player.vy -= 3000 * s * dt;
      if (Math.random()<0.5) particles.push({x:player.x+rand(-6,6)*DPR, y:player.y+player.r*0.9, vx:rand(-50,50), vy:rand(80,160),
        life:1, decay:rand(0.03,0.05), size:rand(2*DPR,4*DPR), hue:40+rand(-10,10)});
    }
    if (player.rainbowT > 0){
      player.rainbowT -= dt;
      const s = sizeJumpScale();
      player.vy -= 3000 * s * dt; // HALF thrust is already encoded by value; this keeps size scaling
      rainbowEngineParticles(player.x, player.y);
    }

    // Ground Pound trail
    if (player.poundTrailT > 0){
      player.poundTrailT -= dt;
      poundTrailParticles(player.x, player.y);
    }

    // Gravity ‚Äî clouds: full effect (1/15) for first 1s, then taper to 1 over next 1s
    let fallFactor = 1;
    if (player.fallSlowT > 0){
      if (player.fallSlowT > 1){
        fallFactor = 1/15;
      } else {
        const t = player.fallSlowT; // 0..1 remaining of taper
        fallFactor = lerp(1, 1/15, t);
      }
      player.fallSlowT -= dt;
    }
    player.vy += world.gravity * dt * fallFactor;

    const prevY = player.y;
    player.x += player.vx * dt;
    player.y += player.vy * dt;

    // Wrap horizontally
    const W = world.width();
    if (player.x < -player.r) player.x = W + player.r;
    if (player.x > W + player.r) player.x = -player.r;

    // Cloud first (no bounce), then platforms
    collideClouds(prevY);
    collidePlatforms(prevY);

    // Camera follows up only
    const targetCam = Math.min(world.cameraY, player.y - world.height()*0.35);
    world.cameraY = lerp(world.cameraY, targetCam, 0.12);

    // Progress
    peakY = Math.min(peakY, player.y);
    maxAscend = Math.max(maxAscend, startY - peakY);

    // Spawn / prune
    populateUpTo(world.cameraY - world.height()*1.2);
    clearLowStuff();

    // Move platforms & crumble decay
    for (let p of platforms){
      if (p.type==='move'){
        p.x += p.dir * p.speed * dt;
        const margin = 60*DPR; if (p.x < margin || p.x > W - margin) p.dir *= -1;
      }
      if (p.hit && p.type==='crumble'){
        p.height = Math.max(6*DPR, p.height - 140*dt*DPR);
        p.width  = Math.max(40*DPR, p.width  - 220*dt*DPR);
        if (p.height <= 6*DPR || p.width <= 42*DPR) p.y = world.cameraY + world.height() + 1000;
      }
    }

    // Particles
    for (let i=particles.length-1;i>=0;i--){
      const pa = particles[i];
      pa.x += pa.vx*dt; pa.y += pa.vy*dt; pa.vy += world.gravity*0.25*dt; pa.life -= pa.decay;
      if (pa.life<=0) particles.splice(i,1);
    }

    // Trail
    player.trail.push({x:player.x, y:player.y}); if (player.trail.length>18) player.trail.shift();

    // Wobble & combo
    if (player.wobble>0) player.wobble = Math.max(0, player.wobble - dt*2.5);
    if (player.comboTimer>0){ player.comboTimer -= dt; if (player.comboTimer<=0) player.combo = 0; }

    // Screen shake decay
    world.shake *= 0.9;

    // Death check (bottom)
    if (player.y - world.cameraY > world.height() + 120*DPR){
      if (player.shield > 0){
        player.shield -= 1;
        playGrossFX();
        world.shake = 7; player.vy = -world.springVel*1.15*sizeJumpScale();
        player.y = world.cameraY + world.height()*0.85;
        burst(player.x, player.y, 12, 30, 50);
        // Cancel ground-pound state, clear buff, stop trail; reset SIZE (color stays)
        player.poundActive = false; player.poundBuffPending = false; player.poundTrailT = 0;
        player.r = BASE_R;
        return;
      }
      gameState = STATE.DEAD;
      playWahWahFX();
      world.shake = 6;
      burst(player.x, world.cameraY + world.height()*0.9, 12, 36, 0);
      const score = metersFromPixels(maxAscend);
      if (score > best){ best = score; localStorage.setItem('sb_v12_high', best); }
    }
  }

  // ‚Äî‚Äî‚Äî Drawing ‚Äî‚Äî‚Äî
  function drawBackground(){
    const W = world.width(), H = world.height();
    const k = clamp(maxAscend/6000, 0, 1);
    const g = ctx.createLinearGradient(0,H,0,0);
    g.addColorStop(0, `hsl(${lerp(220,230,k)} 60% 10%)`);
    g.addColorStop(1, `hsl(${lerp(205,210,k)} 70% 18%)`);
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

    // Stars
    ctx.save();
    for (let i=0;i<stars.length;i++){
      const layer = stars[i]; ctx.globalAlpha = 0.22 + i*0.12;
      for (const s of layer){
        const x = s.x*W;
        const y = ((s.y*H*3) + (world.cameraY * s.speed)) % (H*3);
        ctx.fillStyle = `hsl(${s.hue} 70% 85%)`;
        ctx.fillRect(x, (y+H*3)% (H*3) - H, s.size, s.size);
      }
    }
    ctx.restore();
  }
  function rr(x,y,w,h,r){
    const rr=Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y); ctx.lineTo(x+w-rr,y); ctx.quadraticCurveTo(x+w,y,x+w,y+rr);
    ctx.lineTo(x+w,y+h-rr); ctx.quadraticCurveTo(x+w,y+h,x+w-rr,y+h);
    ctx.lineTo(x+rr,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-rr);
    ctx.lineTo(x,y+rr); ctx.quadraticCurveTo(x,y,x+rr,y); ctx.closePath(); ctx.fill();
  }
  function drawPlatform(p){
    const x=p.x, y=p.y - world.cameraY;
    const w=p.width, h=p.height, r=10*DPR;

    // shadow
    ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(x-w/2, y+4*DPR, w, h);

    // body gradient per type
    const grad = ctx.createLinearGradient(x,y-h,x,y+h);
    if (p.type==='spring'){ grad.addColorStop(0,'hsl(120 70% 55%)'); grad.addColorStop(1,'hsl(120 60% 40%)'); }
    else if (p.type==='crumble'){ grad.addColorStop(0,'hsl(30 60% 60%)'); grad.addColorStop(1,'hsl(20 50% 42%)'); }
    else if (p.type==='move'){ grad.addColorStop(0,'hsl(260 70% 60%)'); grad.addColorStop(1,'hsl(260 60% 45%)'); }
    else if (p.type==='booster'){ grad.addColorStop(0,'hsl(100 70% 42%)'); grad.addColorStop(1,'hsl(100 60% 32%)'); }
    else if (p.type==='rainbow'){
      const rg = ctx.createLinearGradient(x-w/2, y, x+w/2, y);
      const stops = [[0,'#f33'],[0.17,'#fd3'],[0.34,'#ff3'],[0.51,'#3f3'],[0.68,'#3ff'],[0.85,'#39f'],[1,'#c3f']];
      stops.forEach(([t,c])=>rg.addColorStop(t,c));
      ctx.fillStyle = rg; rr(x-w/2, y-h, w, h, r);
      // glow overlay + chevrons
      ctx.globalAlpha=0.25; ctx.fillStyle='#fff'; rr(x-w/2, y-h, w, h*0.4, r); ctx.globalAlpha=1;
      ctx.globalAlpha=0.9; ctx.fillStyle='#fff';
      for (let i=0;i<2;i++){
        ctx.beginPath();
        const yy = y - h*0.65 + i*6*DPR;
        ctx.moveTo(x, yy); ctx.lineTo(x - w*0.18, yy + h*0.28); ctx.lineTo(x + w*0.18, yy + h*0.28); ctx.closePath(); ctx.fill();
      }
      ctx.globalAlpha=1;
    } else { // normal/blue
      grad.addColorStop(0,'hsl(200 70% 60%)'); grad.addColorStop(1,'hsl(200 60% 45%)');
    }

    if (p.type!=='rainbow'){
      ctx.fillStyle = grad; rr(x-w/2, y-h, w, h, r);
    }

    // SLIME overlay (fixed hue; only if hasSlime)
    if (p.hasSlime){
      const slimeColor = `hsl(${p.slimeHue} 90% 55%)`;
      ctx.save();
      ctx.translate(x, y - h*0.5);
      ctx.globalAlpha = 0.80;
      ctx.fillStyle = slimeColor;
      // blobby shape
      ctx.beginPath();
      const sw = w * 0.6, sh = h * 0.9;
      ctx.ellipse(0, 0, sw*0.5, sh*0.55, 0, 0, TAU);
      ctx.fill();
      // highlight
      ctx.globalAlpha = 0.25; ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.ellipse(-sw*0.15, -sh*0.15, sw*0.18, sh*0.18, 0, 0, TAU); ctx.fill();
      ctx.restore();
    }

    // spring coils
    if (p.type==='spring'){
      ctx.strokeStyle = 'hsl(120 30% 20%)'; ctx.lineWidth=2*DPR; ctx.beginPath();
      const coils=5, top=y-h-3*DPR, bot=y-1*DPR;
      for (let i=0;i<=coils;i++){ const t=i/coils; const X=x - w*0.35 + (w*0.7)*t; const Y=lerp(bot, top, (i%2));
        if (!i) ctx.moveTo(X,Y); else ctx.lineTo(X,Y); }
      ctx.stroke();
    }
    // move arrow
    if (p.type==='move'){
      ctx.globalAlpha=0.7; ctx.fillStyle='#fff'; ctx.beginPath();
      ctx.moveTo(x + (p.dir>0? w*0.32 : -w*0.32), y - h*0.65);
      ctx.lineTo(x + (p.dir>0? w*0.05 : -w*0.05), y - h*0.65);
      ctx.lineTo(x + (p.dir>0? w*0.22 : -w*0.22), y - h*0.35);
      ctx.closePath(); ctx.fill(); ctx.globalAlpha=1;
    }
    // cracks for crumble
    if (p.type==='crumble'){
      ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=1.5*DPR;
      ctx.beginPath(); ctx.moveTo(x-w*0.3, y-h*0.7); ctx.lineTo(x-w*0.1, y-h*0.3); ctx.lineTo(x+w*0.15, y-h*0.5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+w*0.22, y-h*0.8); ctx.lineTo(x+w*0.05, y-h*0.45); ctx.stroke();
    }

    // Power-up icon (2√ó size)
    if (p.power){
      const py = y - h - 24*DPR;           // doubled offset
      const rad = 20*DPR;                  // doubled radius
      ctx.save(); ctx.translate(x, py);
      ctx.fillStyle='rgba(255,255,255,0.15)'; ctx.beginPath(); ctx.arc(0,0,rad,0,TAU); ctx.fill();
      ctx.lineWidth=2.5*DPR; ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.arc(0,0,rad,0,TAU); ctx.stroke();
      ctx.font=`bold ${20*DPR}px ui-rounded, ui-sans-serif`; // doubled font
      ctx.textAlign='center'; ctx.textBaseline='middle';
      let label='?';
      if (p.power==='jetpack') label='üöÄ';
      else if (p.power==='ground') label='üí•';
      else if (p.power==='shield') label='üõ°Ô∏è';
      else if (p.power==='cursed') label='‚ò£Ô∏è';
      ctx.fillStyle='#fff'; ctx.fillText(label, 0, 1*DPR);
      ctx.restore();
    }
  }

  function drawCloud(c){
    const x=c.x, y=c.y - world.cameraY, w=c.w, h=c.h;
    ctx.save();
    ctx.globalAlpha = 0.18; ctx.fillStyle = '#fff'; rr(x-w/2, y-h/2, w, h, 16*DPR);
    ctx.globalAlpha = 0.35; rr(x-w*0.45, y-h*0.35, w*0.9, h*0.7, 14*DPR);
    ctx.restore();
  }

  function drawPlayer(){
    const y = player.y - world.cameraY, x = player.x;

    // trail
    ctx.save();
    for (let i=0;i<player.trail.length;i++){
      const t = player.trail[i], k=i/player.trail.length; ctx.globalAlpha = k*0.18;
      ctx.beginPath(); ctx.arc(t.x, t.y - world.cameraY, player.r*(0.75 + k*0.35), 0, TAU);
      ctx.fillStyle = `hsl(${player.color.h} ${player.color.s}% ${player.color.l}%)`; ctx.fill();
    }
    ctx.restore();

    // squash/stretch
    const vyN = clamp(Math.abs(player.vy)/1200,0,1);
    const sStretch = (player.vy<0 ? 1+vyN*0.15 : 1-vyN*0.12);
    const wob = easeOutBack(1 - player.wobble) * 0.18;
    const sx = 1 - (sStretch-1) + wob, sy = sStretch - wob;

    // shadow
    ctx.fillStyle='rgba(0,0,0,0.35)';
    ctx.beginPath(); ctx.ellipse(x, y+player.r*0.9, player.r*0.9, player.r*0.25, 0, 0, TAU); ctx.fill();

    // body
    ctx.save(); ctx.translate(x, y); ctx.scale(sx, sy);
    const grad = ctx.createRadialGradient(-player.r*0.4, -player.r*0.6, player.r*0.2, 0, 0, player.r*1.2);
    grad.addColorStop(0,`hsl(${player.color.h} ${player.color.s}% ${Math.min(95, player.color.l+28)}%)`);
    grad.addColorStop(1,`hsl(${player.color.h} ${player.color.s}% ${player.color.l}%)`);
    ctx.fillStyle=grad; ctx.strokeStyle=`hsl(${player.color.h} 65% 30%)`; ctx.lineWidth=3*DPR;
    ctx.beginPath(); ctx.ellipse(0,0,player.r,player.r,0,0,TAU); ctx.fill(); ctx.stroke();

    // face
    const blink = Math.random()<0.003 ? 0.1 : 1;
    const eyeOffX=10*DPR, eyeOffY=-6*DPR, eyeW=6*DPR, eyeH=10*DPR*blink;
    const look = clamp(player.vx/400,-1,1)*4*DPR;
    ctx.fillStyle='#0b0f1d';
    ctx.beginPath(); ctx.ellipse(-eyeOffX+look, eyeOffY, eyeW, eyeH, 0, 0, TAU); ctx.fill();
    ctx.beginPath(); ctx.ellipse(+eyeOffX+look, eyeOffY, eyeW, eyeH, 0, 0, TAU); ctx.fill();

    // smile
    ctx.strokeStyle='#091124'; ctx.lineWidth=2.5*DPR; ctx.beginPath(); ctx.arc(0, 6*DPR, 10*DPR, 0.1*Math.PI, 0.9*Math.PI); ctx.stroke();
    ctx.restore();
  }

  function drawParticles(){
    ctx.save();
    for (const p of particles){
      ctx.globalAlpha = Math.max(0, p.life);
      ctx.fillStyle = `hsl(${p.hue} 80% 70%)`;
      ctx.beginPath(); ctx.arc(p.x, p.y - world.cameraY, p.size, 0, TAU); ctx.fill();
    }
    ctx.restore();
  }

  function drawHUD(){
    const W=world.width(), H=world.height();
    const score = metersFromPixels(maxAscend);

    // score
    ctx.font = `${24*DPR}px/1.2 ui-rounded, ui-sans-serif, system-ui`;
    ctx.textAlign='left'; ctx.textBaseline='top';
    ctx.fillStyle='rgba(240,245,255,0.9)';
    ctx.fillText(`${score} m`, 14*DPR, 12*DPR);

    // combo
    if (player.combo>0 && player.comboTimer>0){
      ctx.textAlign='center';
      ctx.font = `bold ${22*DPR}px/1.2 ui-rounded, ui-sans-serif`;
      ctx.fillStyle=`hsl(${lerp(40,140, clamp(player.combo/9,0,1))} 80% 60%)`;
      ctx.fillText(`Combo x${player.combo.toFixed(0)}`, W/2, 14*DPR);
    }

    // best
    ctx.textAlign='right';
    ctx.font = `${14*DPR}px/1.2 ui-rounded, ui-sans-serif`;
    ctx.fillStyle='rgba(220,230,255,0.7)';
    ctx.fillText(`Best ${best} m`, W-12*DPR, 16*DPR);

    // centered power-up HUD (2√ó icons) ‚Äî now only Ground + Jetpack
    const slotW=64*DPR, slotH=64*DPR, pad=12*DPR;
    const slotOrder = ['ground','jetpack'];
    const totalW = slotW*slotOrder.length + pad*(slotOrder.length-1);
    const baseX = (W - totalW)/2, baseY = H - (slotH + 28*DPR);
    const glyphOf = { ground:'üí•', jetpack:'üöÄ' };

    ctx.textAlign='left'; ctx.font=`${12*DPR}px/1.2 ui-rounded, ui-sans-serif`; ctx.fillStyle='rgba(200,210,235,0.6)';
    const footerHelp = gameState===STATE.DEAD
      ? `${muted?'üîá':'üîä'} M  ¬∑  ‚è∏ P  ¬∑  I info  ¬∑  ‚èé restart  ¬∑  ‚óÄ/‚ñ∂ move  ¬∑  ‚ñºüí•  ‚ñ≤üöÄ`
      : `${muted?'üîá':'üîä'} M  ¬∑  ‚è∏ P  ¬∑  I info  ¬∑  ‚óÄ/‚ñ∂ move  ¬∑  ‚ñºüí•  ‚ñ≤üöÄ`;
    ctx.fillText(footerHelp, 14*DPR, H - 22*DPR);

    for (let i=0;i<slotOrder.length;i++){
      const type = slotOrder[i];
      const x = baseX + i*(slotW+pad), y=baseY;
      ctx.fillStyle='rgba(255,255,255,0.08)'; rr(x, y, slotW, slotH, 12*DPR);
      ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=1*DPR; ctx.strokeRect(x+0.5*DPR,y+0.5*DPR,slotW-1*DPR,slotH-1*DPR);
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font = `bold ${36*DPR}px ui-rounded, ui-sans-serif`;
      if (type==='jetpack'){
        if (fixedInv.jetpack>0){ ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fillText(glyphOf[type], x+slotW/2, y+slotH/2);
          ctx.font = `bold ${24*DPR}px ui-rounded, ui-sans-serif`; ctx.fillText(`x${fixedInv.jetpack}`, x+slotW/2, y+slotH-14*DPR); }
      } else if (type==='ground'){
        if (fixedInv.ground){ ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fillText(glyphOf[type], x+slotW/2, y+slotH/2); }
      }
    }

    // BIG shield counter (auto-shield charges)
    if (player.shield>0){
      ctx.textAlign='right';
      ctx.font=`bold ${48*DPR}px ui-rounded, ui-sans-serif`;
      ctx.fillStyle='rgba(200,255,230,0.9)';
      ctx.fillText(`üõ°Ô∏è x${player.shield}`, W-18*DPR, H - 80*DPR);
    }

    // game over
    if (gameState===STATE.DEAD){
      ctx.textAlign='center';
      ctx.font = `bold ${Math.floor(40*DPR)}px/1 ui-rounded, ui-sans-serif`;
      ctx.fillStyle='rgba(250,255,255,0.95)'; ctx.fillText('GAME OVER', W/2, H/2 - 22*DPR);
      ctx.font = `${16*DPR}px/1 ui-rounded, ui-sans-serif`;
      ctx.fillStyle='rgba(230,240,255,0.85)'; ctx.fillText('Press ‚èé Enter to Restart', W/2, H/2 + 8*DPR);
    }

    // info overlay
    if (showInfo){
      ctx.save();
      ctx.fillStyle='rgba(5,10,20,0.84)'; ctx.fillRect(0,0,W,H);
      const text = [
        'PLATFORMS:',
        '‚Ä¢ BLUE Normal ‚Äî basic solid. (RARELY has colored slime; landing paints your blob & grows it a bit)',
        '‚Ä¢ GREEN Spring ‚Äî extra bounce.',
        '‚Ä¢ PURPLE Move ‚Äî 2√ó faster side-to-side.',
        '‚Ä¢ ORANGE Crumble ‚Äî shrinks away shortly after landing.',
        '‚Ä¢ DARK GREEN Booster ‚Äî big single burst (rarer).',
        '‚Ä¢ RAINBOW ‚Äî wide tail, sustained jet (half thrust, 2√ó duration; very rare ‚â§0.25%).',
        '',
        'CLOUDS (not platforms):',
        '‚Ä¢ Entering a cloud instantly cuts your vertical speed to 25%,',
        '  then gravity is ~15√ó weaker for 1s and smoothly returns to normal over the next 1s.',
        '',
        'POWER-UPS:',
        '‚Ä¢ üöÄ Rocket (‚ñ≤ or 2): stack to 3; press to jet upward.',
        '‚Ä¢ üí• Ground Pound (‚ñº or 1): slam down; breaks through CRUMBLE (no bounce).',
        '  Your NEXT real bounce afterwards is +50% (all types, including rainbow‚Äôs initial kick).',
        '‚Ä¢ üõ°Ô∏è Shield: auto-collect to charges; triggers on fall to save you.',
        '‚Ä¢ ‚ò£Ô∏è Cursed (auto): removes one shield immediately.',
        '',
        'SIZE & JUMP:',
        `‚Ä¢ Blob grows on slime landings (cap ${MAX_R}). Shield trigger resets SIZE to base (color stays).`,
        `‚Ä¢ Bigger blob jumps lower ‚Äî at max size, upward velocity is ${Math.round(MIN_JUMP_SCALE*100)}% of normal (height ‚âà ${Math.round(MIN_JUMP_SCALE*MIN_JUMP_SCALE*100)}%).`,
        '',
        'Controls: A/D or ‚óÄ/‚ñ∂ move ¬∑ ‚ñºüí• ¬∑ ‚ñ≤üöÄ ¬∑ M mute ¬∑ P pause ¬∑ I info ¬∑ ‚èé restart (when dead)'
      ];
      const W2 = Math.min(W*0.86, 720*DPR), X = (W-W2)/2, Y = H*0.10;
      ctx.fillStyle='rgba(255,255,255,0.08)'; rr(X, Y, W2, 0, 12*DPR);
      ctx.fillStyle='rgba(255,255,255,0.08)'; rr(X, Y, W2, 520*DPR, 12*DPR);
      ctx.textAlign='left'; ctx.textBaseline='top';
      let yy = Y + 18*DPR, xx = X + 18*DPR;
      ctx.font = 'bold ' + (22*DPR) + 'px ui-rounded, ui-sans-serif';
      ctx.fillStyle = 'rgba(240,245,255,0.95)';
      ctx.fillText('Skyward Blob ‚Äî Info', xx, yy); yy += 28*DPR;
      ctx.font = (14*DPR) + 'px ui-rounded, ui-sans-serif';
      ctx.fillStyle = 'rgba(220,230,255,0.92)';
      for (const line of text){ ctx.fillText(line, xx, yy); yy += 18*DPR; }
      ctx.restore();
    }

    // footer
    ctx.textAlign='center'; ctx.font=`${10*DPR}px/1 ui-rounded, ui-sans-serif`;
    ctx.fillStyle='rgba(180,195,235,0.5)'; ctx.fillText('Skyward Blob v1.8.0', W/2, H - 10*DPR);
  }

  // ‚Äî‚Äî‚Äî Main loop ‚Äî‚Äî‚Äî
  function frame(){
    const t = performance.now();
    let dt = (t - lastT)/1000; lastT = t;
    dt = clamp(dt, 0, 1/30);

    if (!paused) update(dt);

    drawBackground();

    // camera shake
    let shakeX=0, shakeY=0;
    if (world.shake>0){ shakeX=(Math.random()-0.5)*world.shake*DPR; shakeY=(Math.random()-0.5)*world.shake*DPR; }
    ctx.save(); ctx.translate(shakeX, shakeY);

    // clouds under platforms for visibility
    for (const c of clouds){
      if (c.y > world.cameraY - 120*DPR && c.y < world.cameraY + world.height()+120*DPR) drawCloud(c);
    }

    // platforms
    for (const p of platforms){
      if (p.y > world.cameraY - 80*DPR && p.y < world.cameraY + world.height()+80*DPR) drawPlatform(p);
    }

    drawParticles();
    drawPlayer();

    ctx.restore();
    drawHUD();

    requestAnimationFrame(frame);
  }
  lastT = performance.now();
  requestAnimationFrame(frame);

  // Gentle palette drift (saturation/lightness fixed; hue animates elsewhere via slime)
  setInterval(()=>{ player.color.h = (player.color.h + randi(-1,2) + 360) % 360; }, 240);
  </script>
</body>
</html>
