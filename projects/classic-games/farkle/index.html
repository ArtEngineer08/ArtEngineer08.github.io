<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Farkle — 2 Player</title>
<style>
:root{
  --bg:#0b0f14; --panel-1:#121821; --panel-2:#0e141c;
  --ink:#eaf2ff; --muted:#9bb0c9;
  --accent-1:#5dd6ff; --accent-2:#8b5cf6; --accent-win:#36d399; --accent-lose:#ef4444;
  --radius:16px;
  --shadow-panel:0 10px 30px rgba(0,0,0,.55);
  --shadow-inner:inset 0 1px 0 rgba(255,255,255,.06),
                 inset 0 -1px 0 rgba(0,0,0,.55),
                 0 10px 28px rgba(0,0,0,.35);
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;color:var(--ink);
  font:15px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,sans-serif;
  background:
    radial-gradient(1400px 900px at 10% -10%, #182130 0%, transparent 60%),
    radial-gradient(1400px 900px at 110% 110%, #151d29 0%, transparent 60%),
    var(--bg);
}

/* ===== Shell ===== */
.app{
  max-width:800px;
  margin:clamp(12px,4vmin,24px) auto;
  padding:clamp(12px,2vmin,24px);
  background:linear-gradient(180deg,var(--panel-1),var(--panel-2));
  border:1px solid rgba(255,255,255,.06);
  border-radius:calc(var(--radius) + 6px);
  box-shadow:var(--shadow-panel);
}

/* ===== Header ===== */
.header{
  display:grid; grid-template-columns:1fr auto 1fr; align-items:end; gap:12px; margin-bottom:8px;
}
.center{ text-align:center }
h1{
  margin:0; font-size:22px; letter-spacing:.06em; font-weight:800;
  background:linear-gradient(90deg,#75d0ff,#8b5cf6);
  -webkit-background-clip:text;background-clip:text;color:transparent;
}
.target{ font-size:12px; color:var(--muted); letter-spacing:.2em; text-transform:uppercase }

/* ===== Player strip ===== */
.players{
  display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-bottom:14px;
}
.pcard{
  padding:12px; border-radius:14px; border:1px solid rgba(255,255,255,.08);
  background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(0,0,0,.28));
  box-shadow:var(--shadow-panel);
}
.pname{ font-size:12px; text-transform:uppercase; letter-spacing:.18em; color:var(--muted); margin-bottom:6px }
.pscore{ font-size:28px; font-weight:800 }
.psub{ font-size:12px; color:var(--muted) }
.active{ outline:2px solid rgba(93,214,255,.8); box-shadow:0 0 0 6px rgba(93,214,255,.15) inset; }

/* ===== Main panel (dice) ===== */
.panel{
  position:relative; border:1px solid rgba(255,255,255,.08); border-radius:var(--radius);
  background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(0,0,0,.30));
  box-shadow:var(--shadow-panel); padding:18px 18px 12px; overflow:hidden;
}
.status{
  text-align:center; margin-bottom:10px; min-height:20px; color:var(--muted); font-size:13px;
}
.status .good{ color:var(--accent-win) }
.status .bad{ color:var(--accent-lose) }
.dice-row{ display:flex; flex-wrap:wrap; justify-content:center; gap:18px; margin-bottom:12px }
.die{
  width:90px; height:90px; border-radius:16px; display:grid; place-items:center;
  user-select:none; cursor:pointer; box-shadow:var(--shadow-inner),0 16px 28px rgba(0,0,0,.45);
  transition:transform .12s, filter .2s, opacity .25s, outline-color .15s;
}
.die:hover{ transform:translateY(-4px) }
.die.blank{ opacity:.5; cursor:default }
.die.selected{ outline:3px solid rgba(93,214,255,.95); filter:drop-shadow(0 0 12px rgba(93,214,255,.45)) }
.die.invalid{ outline:3px solid rgba(239,68,68,.95); filter:drop-shadow(0 0 10px rgba(239,68,68,.45)) }
.pipgrid{ width:70%; height:70%; display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr); gap:10% }
.pip{ width:14px; height:14px; border-radius:999px;
  background: radial-gradient(circle at 30% 30%, #fff, #e6edf7 60%, #c4d0e2 100%);
  box-shadow: inset 0 -1px 2px rgba(0,0,0,.25), 0 2px 8px rgba(0,0,0,.25);
  opacity:0; transform:scale(.5); transition:opacity .15s, transform .15s;
}
.pip.on{ opacity:1; transform:scale(1) }

/* die tones */
.die.t1{ background: linear-gradient(145deg,#2b2a4a,#2a3351) }
.die.t2{ background: linear-gradient(145deg,#3b2b61,#2f3b66) }
.die.t3{ background: linear-gradient(145deg,#532a79,#334a7c) }
.die.t4{ background: linear-gradient(145deg,#6a2a85,#2f5f93) }
.die.t5{ background: linear-gradient(145deg,#8c2b8f,#2b78aa) }
.die.t6{ background: linear-gradient(145deg,#ae2b95,#2a90cb) }

/* Controls */
.controls{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:6px }
button{
  appearance:none; border:1px solid rgba(255,255,255,.08); border-radius:12px; cursor:pointer;
  padding:10px 14px; background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(0,0,0,.3));
  color:var(--ink); font:inherit; box-shadow:var(--shadow-inner); transition:transform .08s, filter .18s, opacity .2s;
}
button:hover:not(:disabled){ transform:translateY(-1px) }
button:active:not(:disabled){ transform:translateY(0) scale(.97) }
button:disabled{ opacity:.4; cursor:default }
.primary{
  background:linear-gradient(90deg,#d54591 0%, #2eb6e6 100%); color:#fff; font-weight:700;
  padding:12px 22px; border-radius:999px; min-width:220px;
}

/* Game over overlay */
.overlay{ position:absolute; inset:0; display:none; place-items:center; text-align:center;
  background: radial-gradient(120% 120% at 50% 10%, rgba(141,92,246,.18), rgba(46,182,230,.18) 40%, rgba(0,0,0,.65) 70%);
  backdrop-filter: blur(6px);
}
.overlay .panel{
  padding:22px 26px; border-radius:16px; border:1px solid rgba(255,255,255,.12);
  background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.35));
  box-shadow: var(--shadow-panel);
}
.overlay h2{ margin:0 0 8px; font-size:22px; letter-spacing:.04em }
.final{ font-weight:800; font-size:30px; margin:8px 0 12px }
.w{ color:var(--accent-win) } .l{ color:var(--accent-lose) }

/* Confetti canvas */
#confetti{ position:fixed; inset:0; pointer-events:none }

/* Status line */
.small{ font-size:12px; color:var(--muted) }
kbd{ background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); border-radius:6px; padding:2px 6px; font-size:12px }

/* ===== Side drawers (Cheat Sheet / Rules) ===== */
.drawer{
  position:fixed; top:50%; transform:translateY(-50%);
  z-index:1000;
}
.drawer .panel{
  width:320px; max-width:34vw; max-height:80vh; overflow:auto;
  border:1px solid rgba(255,255,255,.08);
  border-radius:16px;
  background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(0,0,0,.30));
  box-shadow:var(--shadow-panel);
  padding:14px;
  backdrop-filter:blur(6px);
}
.drawer .tab{
  position:absolute; top:50%; transform:translateY(-50%);
  writing-mode:vertical-rl; text-orientation:mixed;
  border:1px solid rgba(255,255,255,.12);
  border-radius:10px;
  padding:8px 10px;
  background:linear-gradient(90deg,#d54591 0%, #2eb6e6 100%);
  color:#fff; cursor:pointer; user-select:none;
  box-shadow:0 6px 20px rgba(0,0,0,.35);
}
.drawer.left{ left:8px }
.drawer.left .tab{ right:-12px }
.drawer.left .panel{ transform:translateX(-120%); transition:transform .25s ease }
.drawer.left.open .panel{ transform:translateX(0) }

.drawer.right{ right:8px }
.drawer.right .tab{ left:-12px }
.drawer.right .panel{ transform:translateX(120%); transition:transform .25s ease }
.drawer.right.open .panel{ transform:translateX(0) }

/* Hide drawers on small screens */
@media (max-width: 980px){
  .drawer{ display:none }
}
.table{
  width:100%; border-collapse:collapse; font-size:14px;
}
.table td{ padding:6px 4px; border-bottom:1px solid rgba(255,255,255,.06) }
.table td:first-child{ color:var(--ink) }
.table td:last-child{ text-align:right; font-variant-numeric:tabular-nums; color:var(--accent-1) }
.panel h3{ margin:6px 0 8px; font-size:13px; text-transform:uppercase; letter-spacing:.18em; color:var(--muted) }
.panel p{ margin:8px 0 }
.panel ul{ margin:6px 0 8px 1em; padding:0 }
.panel li{ margin:4px 0 }
</style>
</head>
<body>
<!-- Left Drawer: Cheat Sheet -->
<div class="drawer left" id="drawerCheat">
  <button class="tab" id="tabCheat" aria-expanded="false" aria-controls="cheatPanel">Cheat&nbsp;Sheet</button>
  <div class="panel" id="cheatPanel" role="dialog" aria-label="Farkle Scoring Cheat Sheet">
    <h3>Scoring Reference</h3>
    <table class="table">
      <tbody>
        <tr><td>Single 1</td><td>100</td></tr>
        <tr><td>Single 5</td><td>50</td></tr>
        <tr><td>Three of a kind (1s)</td><td>1000</td></tr>
        <tr><td>Three of a kind (2–6)</td><td>Face × 100</td></tr>
        <tr><td>Four of a kind</td><td>1000</td></tr>
        <tr><td>Five of a kind</td><td>2000</td></tr>
        <tr><td>Six of a kind</td><td>3000</td></tr>
        <tr><td>Straight (1–6)</td><td>1500</td></tr>
        <tr><td>Three pairs</td><td>1500</td></tr>
        <tr><td>Four of a kind + a pair</td><td>1500</td></tr>
        <tr><td>Two triplets</td><td>2500</td></tr>
      </tbody>
    </table>
    <p class="small">Score only what you pull from the <em>current</em> dice. Using all six in a sequence of keeps is “Hot Dice” — roll all six again.</p>
  </div>
</div>

<!-- Right Drawer: Rules -->
<div class="drawer right" id="drawerRules">
  <button class="tab" id="tabRules" aria-expanded="false" aria-controls="rulesPanel">Rules</button>
  <div class="panel" id="rulesPanel" role="dialog" aria-label="Farkle Rules">
    <h3>Basics</h3>
    <ul>
      <li>Roll 6 dice. Keep any scoring dice/combos.</li>
      <li>If you kept at least one score, either <strong>Keep &amp; Roll</strong> the rest or <strong>Bank &amp; Pass</strong>.</li>
      <li><strong>Farkle</strong>: a roll with no scoring dice → lose your turn’s subtotal.</li>
      <li><strong>Hot Dice</strong>: if you score with all six, roll all six again (same turn).</li>
      <li>First to <strong>10,000</strong> triggers a final turn for the other player.</li>
    </ul>
    <h3>Shortcuts</h3>
    <p class="small">
      <kbd>Space</kbd> Keep &amp; Roll &nbsp; • &nbsp;
      <kbd>Enter</kbd> Bank &amp; Pass &nbsp; • &nbsp;
      <kbd>C</kbd> Clear &nbsp; • &nbsp;
      <kbd>1–6</kbd> toggle a die
    </p>
  </div>
</div>

<canvas id="confetti"></canvas>
<div class="app">

  <div class="header">
    <div></div>
    <div class="center">
      <h1>FARKLE</h1>
      <div class="target">First to 10,000 — opponent gets one last turn</div>
    </div>
    <div></div>
  </div>

  <div class="players">
    <div id="p0" class="pcard active">
      <div class="pname">Player 1</div>
      <div class="pscore" id="p0score">0</div>
      <div class="psub"   id="p0sub">Turn: 0</div>
    </div>
    <div id="p1" class="pcard">
      <div class="pname">Player 2</div>
      <div class="pscore" id="p1score">0</div>
      <div class="psub"   id="p1sub">Turn: 0</div>
    </div>
  </div>

  <section class="panel" id="playPanel">
    <div class="status" id="status">Select scoring dice, then <b>Keep &amp; Roll</b> or <b>Bank &amp; Pass</b>.</div>

    <div class="dice-row" id="diceRow"></div>

    <div class="controls">
      <button id="btnKeep" class="primary">Keep &amp; Roll <span class="small">(Space)</span></button>
      <button id="btnBank">Bank &amp; Pass <span class="small">(Enter)</span></button>
      <button id="btnClear">Clear <span class="small">(C)</span></button>
      <button id="btnNew">New Game</button>
    </div>

    <div class="overlay" id="gameOver">
      <div class="panel">
        <h2 id="goTitle">Game Over</h2>
        <div class="final"><span id="goP0" class="w">0</span> — <span id="goP1" class="l">0</span></div>
        <button id="btnAgain">Play Again</button>
      </div>
    </div>
  </section>

  <div class="small" style="text-align:center;margin-top:10px">
    Shortcuts: <kbd>Space</kbd> keep &amp; roll, <kbd>Enter</kbd> bank &amp; pass, <kbd>C</kbd> clear, <kbd>1–6</kbd> toggle die
  </div>
</div>

<script>
(() => {
/* ===== Web Audio thump ===== */
const AC = window.AudioContext || window.webkitAudioContext;
const audioCtx = AC ? new AC() : null;
async function thump(){
  if(!audioCtx) return;
  if(audioCtx.state==='suspended') await audioCtx.resume();
  const o1=audioCtx.createOscillator(), o2=audioCtx.createOscillator();
  o1.type='triangle'; o2.type='sine';
  o1.frequency.setValueAtTime(120, audioCtx.currentTime);
  o2.frequency.setValueAtTime(90,  audioCtx.currentTime);
  o1.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime+0.09);
  o2.frequency.exponentialRampToValueAtTime(55, audioCtx.currentTime+0.09);
  const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=240;
  const g=audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(1.1, audioCtx.currentTime+0.015);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.22);
  o1.connect(f); o2.connect(f); f.connect(g); g.connect(audioCtx.destination);
  o1.start(); o2.start(); o1.stop(audioCtx.currentTime+0.24); o2.stop(audioCtx.currentTime+0.24);
}

/* ===== Confetti (slow) ===== */
const confettiCanvas=document.getElementById('confetti'), ctx=confettiCanvas.getContext('2d');
function sizeCanvas(){confettiCanvas.width=innerWidth;confettiCanvas.height=innerHeight}
sizeCanvas(); addEventListener('resize', sizeCanvas);
const bits=[];
function burst(n=140){
  for(let i=0;i<n;i++) bits.push({
    x:Math.random()*innerWidth, y:-20*Math.random(),
    v:0.5+Math.random()*1.1, s:4+6*Math.random(),
    a:Math.random()*360, r:1+Math.random()*2,
    c:`hsl(${Math.random()*360},100%,70%)`
  });
}
(function draw(){
  ctx.clearRect(0,0,innerWidth,innerHeight);
  bits.forEach((b,i)=>{ b.y+=b.v; b.a+=b.r;
    ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.a*Math.PI/180);
    ctx.fillStyle=b.c; ctx.fillRect(-b.s/2,-b.s/2,b.s,b.s); ctx.restore();
    if(b.y>innerHeight+50) bits.splice(i,1);
  });
  requestAnimationFrame(draw);
})();

/* ===== DOM ===== */
const diceRow=document.getElementById('diceRow');
const statusEl=document.getElementById('status');
const btnKeep=document.getElementById('btnKeep');
const btnBank=document.getElementById('btnBank');
const btnClear=document.getElementById('btnClear');
const btnNew=document.getElementById('btnNew');
const gameOver=document.getElementById('gameOver');
const goTitle=document.getElementById('goTitle');
const goP0=document.getElementById('goP0');
const goP1=document.getElementById('goP1');
const btnAgain=document.getElementById('btnAgain');

const p0=document.getElementById('p0'), p1=document.getElementById('p1');
const p0score=document.getElementById('p0score'), p1score=document.getElementById('p1score');
const p0sub=document.getElementById('p0sub'), p1sub=document.getElementById('p1sub');

/* ===== Drawers ===== */
const drawerCheat=document.getElementById('drawerCheat');
const drawerRules=document.getElementById('drawerRules');
const tabCheat=document.getElementById('tabCheat');
const tabRules=document.getElementById('tabRules');

function toggleDrawer(drawer, tab){
  const open = !drawer.classList.contains('open');
  // close both, then maybe open target
  drawerCheat.classList.remove('open'); tabCheat.setAttribute('aria-expanded','false');
  drawerRules.classList.remove('open'); tabRules.setAttribute('aria-expanded','false');
  if(open){ drawer.classList.add('open'); tab.setAttribute('aria-expanded','true'); }
}
tabCheat.addEventListener('click', ()=>toggleDrawer(drawerCheat, tabCheat));
tabRules.addEventListener('click', ()=>toggleDrawer(drawerRules, tabRules));
document.addEventListener('keydown', (e)=>{
  if(e.key==='Escape'){
    drawerCheat.classList.remove('open'); tabCheat.setAttribute('aria-expanded','false');
    drawerRules.classList.remove('open'); tabRules.setAttribute('aria-expanded','false');
  }
});
document.addEventListener('click', (e)=>{
  const insideCheat = drawerCheat.contains(e.target);
  const insideRules = drawerRules.contains(e.target);
  if(!insideCheat && !insideRules){
    drawerCheat.classList.remove('open'); tabCheat.setAttribute('aria-expanded','false');
    drawerRules.classList.remove('open'); tabRules.setAttribute('aria-expanded','false');
  }
});

/* ===== State ===== */
const TARGET=10000;
let totals=[0,0];
let turn=0;                 // 0 or 1
let subtotal=0;             // running points this turn
let dice=[];                // current dice values
let selected=[];            // selected mask
let gameEnded=false;
let finalChallenger=null;   // who gets last turn
let inFinalRound=false;

const FACE = {1:[5],2:[1,9],3:[1,5,9],4:[1,3,7,9],5:[1,3,5,7,9],6:[1,3,4,6,7,9]};

/* ===== Utilities ===== */
const rnd=()=>1+Math.floor(Math.random()*6);
const counts=a=>a.reduce((m,v)=>(m[v]=(m[v]||0)+1,m),{});
const sum=a=>a.reduce((x,y)=>x+y,0);

/* Check if any scoring is possible in a pool of dice */
function hasScoring(pool){
  const c=counts(pool);
  if((c[1]||0)>0 || (c[5]||0)>0) return true;
  for(let f=1;f<=6;f++) if((c[f]||0)>=3) return true;
  if(pool.length===6){
    const faces=[1,2,3,4,5,6]; if(faces.every(f=>(c[f]||0)===1)) return true; // straight
    const pairs=Object.values(c).filter(v=>v===2).length; if(pairs===3) return true; // three pairs
    if(Object.values(c).includes(6)) return true;
    if(Object.values(c).includes(5)) return true;
    if(Object.values(c).includes(4) && Object.values(c).includes(2)) return true;
    if(Object.values(c).filter(v=>v===3).length===2) return true;
  }
  return false;
}

/* Score a selection (must be entirely scorable). Returns {valid, points, breakdown} */
function scoreSelection(sel){
  if(!sel.length) return {valid:false, points:0, breakdown:[]};
  const c=counts(sel);
  const n=sel.length;
  if(n===6){
    const faces=[1,2,3,4,5,6];
    if(faces.every(f=>(c[f]||0)===1)) return {valid:true, points:1500, breakdown:['Straight (1–6) 1500']};
    const pairCnt=Object.values(c).filter(v=>v===2).length;
    if(pairCnt===3) return {valid:true, points:1500, breakdown:['Three Pairs 1500']};
    if(Object.values(c).includes(6)) return {valid:true, points:3000, breakdown:['Six of a Kind 3000']};
    if(Object.values(c).includes(5)){
      return {valid:true, points:2000 + (c[1]===1?100:0) + (c[5]===1?50:0),
        breakdown:['Five of a Kind 2000'].concat(c[1]===1?['+ 1 = 100']:[]).concat(c[5]===1?['+ 5 = 50']:[])};
    }
    if(Object.values(c).includes(4) && Object.values(c).includes(2))
      return {valid:true, points:1500, breakdown:['Four of a Kind + Pair 1500']};
    if(Object.values(c).filter(v=>v===3).length===2)
      return {valid:true, points:2500, breakdown:['Two Triplets 2500']};
  }
  let pts=0, bb=[];
  for(let f=1;f<=6;f++){
    let k=c[f]||0;
    if(k>=6){ pts+=3000; bb.push('Six of a Kind 3000'); k-=6; }
    if(k>=5){ pts+=2000; bb.push('Five of a Kind 2000'); k-=5; }
    if(k>=4){ pts+=1000; bb.push('Four of a Kind 1000'); k-=4; }
    if(k>=3){ const v=(f===1)?1000:f*100; pts+=v; bb.push(`Three ${f}s ${v}`); k-=3; }
    c[f]=k;
  }
  if((c[1]||0)>0){ pts+= (c[1]*100); if(c[1]) bb.push(`${c[1]}×1 = ${c[1]*100}`); c[1]=0; }
  if((c[5]||0)>0){ pts+= (c[5]*50 ); if(c[5]) bb.push(`${c[5]}×5 = ${c[5]*50}` ); c[5]=0; }
  const leftover = Object.values(c).some(v=>v>0);
  return {valid:!leftover && pts>0, points:pts, breakdown:bb};
}

/* ===== Rendering ===== */
function dieEl(val, i, selectedIdx){
  const el=document.createElement('div');
  el.className=`die t${val}` + (selectedIdx? ' selected':'');
  el.onclick=()=>toggle(i);
  const pg=document.createElement('div'); pg.className='pipgrid';
  for(let k=1;k<=9;k++){
    const p=document.createElement('span');
    p.className='pip'+(FACE[val].includes(k)?' on':'');
    pg.appendChild(p);
  }
  el.appendChild(pg);
  return el;
}

function render(){
  // players
  p0.classList.toggle('active', turn===0);
  p1.classList.toggle('active', turn===1);
  p0score.textContent=totals[0]; p1score.textContent=totals[1];
  p0sub.textContent='Turn: '+(turn===0?subtotal:0);
  p1sub.textContent='Turn: '+(turn===1?subtotal:0);

  // dice
  diceRow.innerHTML='';
  dice.forEach((v,i)=> diceRow.appendChild(dieEl(v, i, selected[i])) );

  // selection validity + buttons
  const selVals = dice.filter((_,i)=>selected[i]);
  const sc = scoreSelection(selVals);
  const canKeep = sc.valid;
  btnKeep.disabled = !canKeep || gameEnded;
  btnBank.disabled = (subtotal<=0) || gameEnded;
  btnClear.disabled = selVals.length===0 || gameEnded;

  // status line
  if(gameEnded){
    statusEl.innerHTML = `<span class="bad">Game over.</span>`;
  }else if(!dice.length){
    statusEl.innerHTML = `Hot dice! Roll all six.`;
  }else if(!hasScoring(dice)){
    statusEl.innerHTML = `<span class="bad">Farkle! No scoring dice.</span>`;
  }else if(canKeep){
    statusEl.innerHTML = `Selection: <span class="good">+${sc.points}</span> — ${sc.breakdown.join(' · ')}`;
  }else if(selVals.length){
    statusEl.innerHTML = `<span class="bad">Selection isn’t scorable. Use only 1s, 5s, or valid sets.</span>`;
  }else{
    statusEl.innerHTML = `Select scoring dice, then <b>Keep &amp; Roll</b> or <b>Bank &amp; Pass</b>.`;
  }

  // mark invalid selection visually
  [...diceRow.children].forEach((el,i)=>{
    if(selected[i] && selVals.length){
      el.classList.toggle('invalid', !sc.valid);
    }else{
      el.classList.remove('invalid');
    }
  });
}

/* ===== Turn / Game flow ===== */
function newTurn(next){
  turn = next;
  subtotal = 0;
  dice = [1,1,1,1,1,1]; // placeholders; roll them immediately
  selected = [false,false,false,false,false,false];
  render();
  rollFresh();
}

function toggle(i){
  if(gameEnded) return;
  selected[i] = !selected[i];
  render();
}

async function rollFresh(){
  if(gameEnded) return;
  thump();
  await animateRoll(dice.map(()=>true));
  dice = dice.map(()=>rnd());
  selected = dice.map(()=>false);
  render();

  if(!hasScoring(dice)){
    await flashFarkle();
    subtotal = 0; render(); passTurn();
  }
}

async function keepAndRoll(){
  if(gameEnded) return;
  const selVals = dice.filter((_,i)=>selected[i]);
  const sc = scoreSelection(selVals);
  if(!sc.valid) return;
  subtotal += sc.points;

  const remaining = [];
  dice.forEach((v,i)=>{ if(!selected[i]) remaining.push(v); });
  dice = remaining;
  selected = dice.map(()=>false);

  if(dice.length===0){
    burst(160);
    dice = [1,1,1,1,1,1];
    selected = [false,false,false,false,false,false];
    render();
    await rollFresh();
    return;
  }

  render();
  thump();
  await animateRoll(dice.map(()=>true));
  dice = dice.map(()=>rnd());
  selected = dice.map(()=>false);
  render();

  if(!hasScoring(dice)){
    await flashFarkle();
    subtotal = 0; render(); passTurn();
  }
}

function bankAndPass(){
  if(gameEnded) return;
  if(subtotal<=0) return;
  totals[turn] += subtotal;
  subtotal = 0;
  render();

  if(!inFinalRound && totals[turn] >= TARGET){
    inFinalRound = true;
    finalChallenger = 1 - turn;
  }

  passTurn();
}

function passTurn(){
  if(gameEnded) return;

  if(inFinalRound && turn === finalChallenger){
    endGame(); return;
  }
  newTurn(1 - turn);
}

/* Animate roll for a mask of dice (true for dice that roll) */
function animateRoll(mask){
  return new Promise(res=>{
    const nodes=[...diceRow.children];
    nodes.forEach((el,i)=>{
      if(!mask[i]) return;
      el.style.transform='translateY(0)';
      el.classList.add('rolling');
      let t=0, timer=setInterval(()=>{
        const r=rnd();
        const p=el.querySelectorAll('.pip');
        p.forEach(x=>x.classList.remove('on'));
        (FACE[r]||[]).forEach(idx=>p[idx-1].classList.add('on'));
        if((t+=90)>=500) clearInterval(timer);
      },90);
    });
    setTimeout(()=>{
      nodes.forEach(el=>el.classList.remove('rolling'));
      res();
    },620);
  });
}

function flashFarkle(){
  return new Promise(res=>{
    statusEl.innerHTML = `<span class="bad">FARKLE! Turn lost.</span>`;
    burst(40); // tiny burst
    setTimeout(res, 650);
  });
}

function endGame(){
  gameEnded = true;
  const w = totals[0]===totals[1] ? null : (totals[0]>totals[1]?0:1);
  goP0.textContent = totals[0];
  goP1.textContent = totals[1];
  if(w===0){ goP0.className='w'; goP1.className='l'; goTitle.textContent='Player 1 Wins!'; }
  else if(w===1){ goP0.className='l'; goP1.className='w'; goTitle.textContent='Player 2 Wins!'; }
  else { goP0.className='w'; goP1.className='w'; goTitle.textContent='Tie Game'; }
  burst(260);
  gameOver.style.display='grid';
}

/* ===== Events ===== */
btnKeep.onclick=keepAndRoll;
btnBank.onclick=bankAndPass;
btnClear.onclick=()=>{ selected = dice.map(()=>false); render(); };
btnNew.onclick=()=>reset(true);
btnAgain.onclick=()=>reset(false);

addEventListener('keydown',e=>{
  if(gameEnded) return;
  if(e.code==='Space'){ e.preventDefault(); keepAndRoll(); }
  if(e.code==='Enter'){ e.preventDefault(); bankAndPass(); }
  if(e.key==='c' || e.key==='C'){ selected = dice.map(()=>false); render(); }
  if(/^Digit[1-6]$/.test(e.code)){
    const idx = (+e.code.slice(-1))-1;
    if(idx < dice.length) toggle(idx);
  }
});

/* ===== Boot / Reset ===== */
function reset(swapFirst){
  totals=[0,0]; subtotal=0; gameEnded=false; inFinalRound=false; finalChallenger=null;
  gameOver.style.display='none';
  p0score.textContent=0; p1score.textContent=0;
  p0sub.textContent='Turn: 0'; p1sub.textContent='Turn: 0';
  p0.classList.remove('active'); p1.classList.remove('active');
  turn = swapFirst ? 0 : turn;
  newTurn(turn);
}

newTurn(0);
})();
</script>
</body>
</html>
