<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dark Mode Checkers – Tabletop Sandbox</title>
<style>
  :root{
    --bg: #0b0f14;
    --panel: #121821;
    --panel-2: #0e141c;
    --ink: #eaf2ff;
    --muted: #9bb0c9;
    --accent: #5dd6ff;
    --accent-2: #8b5cf6;

    --sq-light: #2a3342;
    --sq-dark: #1a2230;
    --sq-highlight: #2f3a4d;

    --red: #ff5a6d;
    --black: #b7c4d6;

    --king-gold-1: #f8d772;
    --king-gold-2: #caa43a;

    --radius: 16px;
    --shadow-1: 0 10px 30px rgba(0,0,0,.5);
    --shadow-2: inset 0 1px 0 rgba(255,255,255,.06), inset 0 -1px 0 rgba(0,0,0,.5), 0 8px 20px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background:
      radial-gradient(1200px 800px at 10% -10%, #16202d 0%, rgba(22,32,45,0) 60%),
      radial-gradient(1200px 800px at 110% 110%, #171f2a 0%, rgba(23,31,42,0) 60%),
      var(--bg);
    color:var(--ink);
    font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, sans-serif;
  }

  .app{
    max-width: 1200px;
    margin: clamp(12px,4vmin,24px) auto;
    padding: clamp(12px,2vmin,24px);
    background: linear-gradient(180deg, var(--panel), var(--panel-2));
    border: 1px solid rgba(255,255,255,.06);
    border-radius: calc(var(--radius) + 4px);
    box-shadow: var(--shadow-1);
  }

  header{
    display:flex; gap:16px; align-items:center; justify-content:space-between;
    margin-bottom: 14px;
  }
  .title{
    display:flex; align-items:center; gap:12px;
  }
  .badge{
    font-size:12px; color:var(--muted);
    background: rgba(255,255,255,.04);
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,.06);
    backdrop-filter: blur(6px);
  }

  .toolbar{
    display:flex; gap:10px; flex-wrap: wrap;
  }
  button, .toggle{
    appearance:none; border:0; cursor:pointer;
    padding:10px 14px; border-radius: 12px;
    color: var(--ink);
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.3));
    border:1px solid rgba(255,255,255,.08);
    box-shadow: var(--shadow-2);
    transition: transform .08s ease, box-shadow .2s ease, background .2s ease;
  }
  button:hover, .toggle:hover{ transform: translateY(-1px) }
  button:active, .toggle:active{ transform: translateY(0) scale(.98) }

  .toggle{
    display:inline-flex; align-items:center; gap:10px;
  }
  .dot{
    width:10px; height:10px; border-radius:999px;
    background: var(--accent);
    box-shadow: 0 0 12px var(--accent);
  }
  .dot.off{ background:#45566e; box-shadow:none }

  .play-area{
    position: relative;
    isolation: isolate;
    display:grid;
    grid-template-columns: 1fr auto 1fr;
    gap: clamp(10px, 2vmin, 18px);
    align-items: start;
  }

  /* Board */
  .board-wrap{
    grid-column: 2;
    display:grid; place-items:center;
    padding: clamp(8px, 1.5vmin, 14px);
    background:
      radial-gradient(120% 140% at 50% -20%, rgba(93,214,255,.08), rgba(139,92,246,.06) 48%, transparent 52%),
      linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.4));
    border-radius: var(--radius);
    border:1px solid rgba(255,255,255,.08);
    box-shadow: var(--shadow-1);
  }
  .board{
    position:relative;
    width:min(80vmin, 640px);
    aspect-ratio: 1 / 1;
    border-radius: calc(var(--radius) - 6px);
    overflow:hidden;
    box-shadow: 0 25px 60px rgba(0,0,0,.6);
    border:1px solid rgba(255,255,255,.08);
  }

  .grid{
    display:grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    width:100%; height:100%;
    background: var(--sq-dark);
  }
  .cell{
    position:relative;
    background: var(--sq-light);
  }
  .cell.dark{ background: var(--sq-dark) }
  .cell::after{
    /* subtle inner gloss */
    content:"";
    position:absolute; inset:0;
    background: radial-gradient(120% 90% at 50% -10%, rgba(255,255,255,.06), transparent 50%);
    pointer-events:none;
  }
  .cell.highlight{
    outline: 2px dashed rgba(255,255,255,.15);
    outline-offset: -4px;
    background: var(--sq-highlight);
  }

  /* Side trays */
  .tray{
    position:relative;
    min-height: min(80vmin, 640px);
    background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.35));
    border:1px dashed rgba(255,255,255,.12);
    border-radius: var(--radius);
    padding:12px;
    box-shadow: var(--shadow-1);
  }
  .tray h3{
    margin:0 0 8px 0; font-weight:600; font-size:13px; color:var(--muted);
    letter-spacing:.3px;
  }
  .tray .hint{
    font-size:12px; color:var(--muted); opacity:.8; margin-bottom:6px;
  }

  /* Draggable tokens live inside .tokens layer spanning the play-area */
  .tokens{
    position:absolute; inset:0;
    pointer-events:none; /* children re-enable */
  }

  /* Pieces */
  .piece, .crown{
    position:absolute;
    width: clamp(42px, 9vmin, 64px);
    aspect-ratio: 1 / 1;
    border-radius: 999px;
    pointer-events: auto;
    user-select: none;
    touch-action: none;
    cursor: grab;
    transform: translate(-50%, -50%); /* positioned by center */
  }
  .piece:active, .crown:active{ cursor: grabbing }

  .piece{
    background:
      radial-gradient(120% 120% at 30% 30%, rgba(255,255,255,.25), rgba(255,255,255,0) 50%),
      radial-gradient(120% 120% at 70% 70%, rgba(0,0,0,.35), rgba(0,0,0,0) 40%),
      linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.45));
    border: 1px solid rgba(255,255,255,.12);
    box-shadow: var(--shadow-2), 0 18px 40px rgba(0,0,0,.5);
  }
  .piece.red{ background-color: var(--red) }
  .piece.black{ background-color: #344861 } /* body base; highlights add depth */
  .piece.black::before{
    content:""; position:absolute; inset:0; border-radius:999px;
    background: radial-gradient(120% 120% at 30% 30%, rgba(255,255,255,.18), transparent 50%);
    mix-blend-mode:screen; pointer-events:none;
  }

  /* King flair on pieces via class */
  .piece.king{
    outline: 3px solid rgba(248, 215, 114, .9);
    box-shadow: 0 0 0 2px rgba(0,0,0,.35) inset, var(--shadow-2), 0 18px 40px rgba(0,0,0,.5);
  }
  .piece.king .svg-crown{
    position:absolute; inset: 18% 18%;
    opacity:.95; filter: drop-shadow(0 2px 2px rgba(0,0,0,.35));
    pointer-events:none;
  }

  /* Loose crown tokens (for manual crowning) */
  .crown{
    width: clamp(30px, 6.5vmin, 48px);
    background:
      radial-gradient(120% 120% at 30% 30%, rgba(255,255,255,.35), rgba(255,255,255,0) 55%),
      linear-gradient(180deg, var(--king-gold-1), var(--king-gold-2));
    border:1px solid rgba(0,0,0,.35);
    box-shadow: var(--shadow-2), 0 16px 36px rgba(0,0,0,.5);
  }
  .crown .svg-crown{
    position:absolute; inset: 18% 18%;
    opacity:.95; filter: drop-shadow(0 2px 2px rgba(0,0,0,.35));
    pointer-events:none;
  }

  /* Labels around board */
  .labels{
    position:absolute; inset:0; pointer-events:none; font-size:12px; color:var(--muted);
  }
  .rank, .file{ position:absolute; opacity:.85 }
  .rank{ left:4px }
  .file{ top:4px }

  /* Helper tooltip (bottom-left) */
  .helper{
    margin-top:10px; color:var(--muted); font-size:13px;
  }
  .helper code{ color:var(--ink); background:rgba(255,255,255,.06); padding:2px 6px; border-radius:6px }

  @media (max-width: 980px){
    .play-area{ grid-template-columns: 1fr; }
    .board-wrap{ grid-column: 1 }
    .tray{ min-height: auto; }
  }
</style>
</head>
<body>
  <div class="app">
    <header>
      <div class="title">
        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M4 19h16M5 19l3-10h8l3 10M9 9l3-4 3 4" stroke="url(#g1)" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
          <defs>
            <linearGradient id="g1" x1="0" y1="0" x2="24" y2="24" gradientUnits="userSpaceOnUse">
              <stop stop-color="#5dd6ff"/><stop offset="1" stop-color="#8b5cf6"/>
            </linearGradient>
          </defs>
        </svg>
        <h1 style="margin:0;font-size:18px;letter-spacing:.3px;">Checkers – Tabletop Sandbox</h1>
        <span class="badge">Dark • Stylized • No Rules Engine</span>
      </div>
      <div class="toolbar">
        <button id="standardBtn" title="Place the standard 12-per-side layout">Standard Setup</button>
        <button id="emptyBtn"    title="Clear all pieces from the board (keeps trays)">Empty Board</button>
        <button id="resetBtn"    title="Reset everything to initial state">Reset All</button>
        <span class="toggle" id="snapToggle" role="switch" aria-checked="true" tabindex="0" title="Toggle magnetic snap to squares">
          <span class="dot" id="snapDot"></span> Snap to squares
        </span>
      </div>
    </header>

    <div class="play-area" id="playArea">
      <div class="tray" id="trayLeft" aria-label="Captured / Spare (Left)">
        <h3>Tray A</h3>
        <div class="hint">Drop captured pieces here. Crowns available on the right.</div>
      </div>

      <div class="board-wrap">
        <div class="board" id="board">
          <div class="grid" id="grid"></div>
          <div class="labels" id="labels"></div>
        </div>
        <div class="helper">Right-click a checker to <strong>King/Un-King</strong>. Hold <code>Shift</code> while dropping to temporarily bypass snap.</div>
      </div>

      <div class="tray" id="trayRight" aria-label="Captured / Spare (Right)">
        <h3>Tray B</h3>
        <div class="hint">Loose <strong>King</strong> crowns below — drag onto pieces as needed.</div>
      </div>

      <!-- Absolute layer hosting all draggable tokens (pieces & crowns) -->
      <div class="tokens" id="tokensLayer" aria-hidden="true"></div>
    </div>
  </div>

<script>
(() => {
  const playArea = document.getElementById('playArea');
  const tokensLayer = document.getElementById('tokensLayer');
  const board = document.getElementById('board');
  const grid = document.getElementById('grid');
  const labels = document.getElementById('labels');
  const trayLeft = document.getElementById('trayLeft');
  const trayRight = document.getElementById('trayRight');

  const standardBtn = document.getElementById('standardBtn');
  const emptyBtn    = document.getElementById('emptyBtn');
  const resetBtn    = document.getElementById('resetBtn');
  const snapToggle  = document.getElementById('snapToggle');
  const snapDot     = document.getElementById('snapDot');

  let SNAP_ENABLED = true;
  let zTop = 10;

  // Build 8x8 grid
  const files = "ABCDEFGH".split("");
  const ranks = "87654321".split("");
  for (let r = 0; r < 8; r++){
    for (let c = 0; c < 8; c++){
      const cell = document.createElement('div');
      cell.className = 'cell' + (((r + c) % 2 === 0) ? '' : ' dark');
      cell.dataset.row = r;
      cell.dataset.col = c;
      grid.appendChild(cell);
    }
  }
  // Labels (files A-H bottom, ranks 1-8 left)
  function renderLabels(){
    labels.innerHTML = '';
    const br = board.getBoundingClientRect();
    const cell = br.width / 8;
    for (let i=0;i<8;i++){
      const f = document.createElement('div');
      f.className = 'file';
      f.textContent = files[i];
      f.style.left = `${((i+0.5)/8)*100}%`;
      f.style.transform = 'translateX(-50%)';
      f.style.bottom = '4px';
      labels.appendChild(f);

      const r = document.createElement('div');
      r.className = 'rank';
      r.textContent = ranks[i];
      r.style.top = `${((i+0.5)/8)*100}%`;
      r.style.transform = 'translateY(-50%)';
      labels.appendChild(r);
    }
  }
  renderLabels();
  window.addEventListener('resize', renderLabels);

  // SVG crown for kings
  const crownSVG = `
    <svg class="svg-crown" viewBox="0 0 64 64" aria-hidden="true">
      <defs>
        <linearGradient id="kg" x1="0" y1="0" x2="1" y2="1">
          <stop stop-color="#f8d772"/><stop offset="1" stop-color="#caa43a"/>
        </linearGradient>
      </defs>
      <path d="M8 44h48v6H8z" fill="url(#kg)"/>
      <path d="M8 44l8-20 16 12 16-12 8 20H8z" fill="url(#kg)"/>
      <circle cx="16" cy="20" r="4" fill="#fff" opacity=".9"/>
      <circle cx="48" cy="20" r="4" fill="#fff" opacity=".9"/>
      <circle cx="32" cy="18" r="5" fill="#fff" opacity=".9"/>
    </svg>
  `;

  // Helpers: positioning
  function getRects(){
    return {
      area: playArea.getBoundingClientRect(),
      board: board.getBoundingClientRect()
    };
  }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  // Create a checker piece
  function createPiece(color='red', king=false, centerTo=null){
    const el = document.createElement('div');
    el.className = `piece ${color}` + (king ? ' king' : '');
    el.dataset.kind = 'piece';
    el.dataset.color = color;
    el.dataset.king = king ? '1' : '0';
    el.style.left = '50%';
    el.style.top  = '50%';
    el.style.zIndex = (++zTop).toString();
    if (king){
      el.insertAdjacentHTML('beforeend', crownSVG);
    }
    tokensLayer.appendChild(el);

    attachDrag(el);

    // Right-click to toggle king
    el.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      toggleKing(el);
    });

    if (centerTo){
      setCenter(el, centerTo.x, centerTo.y);
    }
    return el;
  }

  function toggleKing(pieceEl){
    const isKing = pieceEl.dataset.king === '1';
    if (isKing){
      pieceEl.dataset.king = '0';
      pieceEl.classList.remove('king');
      const svg = pieceEl.querySelector('.svg-crown');
      if (svg) svg.remove();
    } else {
      pieceEl.dataset.king = '1';
      pieceEl.classList.add('king');
      if (!pieceEl.querySelector('.svg-crown')){
        pieceEl.insertAdjacentHTML('beforeend', crownSVG);
      }
    }
  }

  // Create loose crown token
  function createCrown(centerTo=null){
    const el = document.createElement('div');
    el.className = 'crown';
    el.dataset.kind = 'crown';
    el.style.left = '50%';
    el.style.top  = '50%';
    el.style.zIndex = (++zTop).toString();
    el.insertAdjacentHTML('beforeend', crownSVG);
    tokensLayer.appendChild(el);
    attachDrag(el);
    if (centerTo){
      setCenter(el, centerTo.x, centerTo.y);
    }
    return el;
  }

  // Drag logic (pointer events)
  function attachDrag(el){
    let pointerId = null;
    let offsetX = 0, offsetY = 0;

    const down = (e) => {
      if (pointerId !== null) return;
      pointerId = e.pointerId;
      el.setPointerCapture(pointerId);
      el.style.zIndex = (++zTop).toString();

      const rect = el.getBoundingClientRect();
      offsetX = e.clientX - rect.left - rect.width/2;
      offsetY = e.clientY - rect.top - rect.height/2;

      el.classList.add('dragging');
    };
    const move = (e) => {
      if (pointerId !== e.pointerId) return;
      const { area } = getRects();
      const x = clamp(e.clientX - area.left - offsetX, 0, area.width);
      const y = clamp(e.clientY - area.top - offsetY, 0, area.height);
      setCenter(el, x, y);
      highlightIfOverBoard(x, y);
    };
    const up = (e) => {
      if (pointerId !== e.pointerId) return;
      el.releasePointerCapture(pointerId);
      el.classList.remove('dragging');
      const { area, board: bRect } = getRects();
      const center = getCenter(el);
      const absX = area.left + center.x;
      const absY = area.top + center.y;

      // Snap unless Shift is held or toggle is off
      const shouldSnap = SNAP_ENABLED && !e.shiftKey;

      if (shouldSnap && absX >= bRect.left && absX <= bRect.right && absY >= bRect.top && absY <= bRect.bottom){
        const cellSize = bRect.width / 8;
        const c = Math.floor((absX - bRect.left) / cellSize);
        const r = Math.floor((absY - bRect.top) / cellSize);
        const snapX = (c + 0.5) * cellSize + (bRect.left - area.left);
        const snapY = (r + 0.5) * cellSize + (bRect.top  - area.top);
        setCenter(el, snapX, snapY);
      }
      clearHighlights();
      pointerId = null;
    };

    el.addEventListener('pointerdown', down);
    window.addEventListener('pointermove', move);
    window.addEventListener('pointerup', up);
    window.addEventListener('pointercancel', up);
  }

  function setCenter(el, x, y){
    el.style.left = `${x}px`;
    el.style.top  = `${y}px`;
  }
  function getCenter(el){
    return {
      x: parseFloat(el.style.left),
      y: parseFloat(el.style.top)
    };
  }

  function highlightIfOverBoard(x, y){
    const { area, board: bRect } = getRects();
    const absX = area.left + x;
    const absY = area.top + y;
    const over = (absX >= bRect.left && absX <= bRect.right && absY >= bRect.top && absY <= bRect.bottom);
    if (!over){ clearHighlights(); return; }

    const cellSize = bRect.width / 8;
    const c = Math.floor((absX - bRect.left) / cellSize);
    const r = Math.floor((absY - bRect.top) / cellSize);
    const idx = r*8 + c;
    [...grid.children].forEach((cell,i) => {
      cell.classList.toggle('highlight', i === idx);
    });
  }
  function clearHighlights(){
    [...grid.children].forEach(cell => cell.classList.remove('highlight'));
  }

  // Layout helpers for trays and board centers
  function centerOf(el){
    const { area } = getRects();
    const r = el.getBoundingClientRect();
    return {
      x: (r.left - area.left) + r.width/2,
      y: (r.top  - area.top) + r.height/2
    };
  }
  function squareCenter(row, col){
    const { area, board: bRect } = getRects();
    const cell = bRect.width / 8;
    return {
      x: (col + 0.5) * cell + (bRect.left - area.left),
      y: (row + 0.5) * cell + (bRect.top  - area.top),
    };
  }

  // Setups
  function clearAllPieces(){
    [...tokensLayer.querySelectorAll('.piece')].forEach(n => n.remove());
  }
  function clearAllCrowns(){
    [...tokensLayer.querySelectorAll('.crown')].forEach(n => n.remove());
  }

  function spawnCrowns(count = 8){
    const rightCenter = centerOf(trayRight);
    const spacing = 56;
    for (let i=0;i<count;i++){
      createCrown({ x: rightCenter.x + ((i%2===0)? -spacing : spacing)*((i%4<2)?1:-1)*0 + (i%2? spacing/2 : -spacing/2), y: rightCenter.y - 120 + (i*28) });
    }
  }

  function standardSetup(){
    clearAllPieces();
    // Red at top on dark squares (rows 0-2), Black at bottom (rows 5-7)
    const darkSquare = (r,c) => (r + c) % 2 === 1;
    for (let r=0;r<3;r++){
      for (let c=0;c<8;c++){
        if (!darkSquare(r,c)) continue;
        createPiece('red', false, squareCenter(r,c));
      }
    }
    for (let r=5;r<8;r++){
      for (let c=0;c<8;c++){
        if (!darkSquare(r,c)) continue;
        createPiece('black', false, squareCenter(r,c));
      }
    }
  }

  function emptyBoard(){
    clearAllPieces();
  }

  function initial(){
    emptyBoard();
    standardSetup();               // Start with standard layout
    clearAllCrowns();
    spawnCrowns(10);               // Spare King crowns off-board
    // Add a couple of ready-made King checkers off-board too
    const leftCenter = centerOf(trayLeft);
    createPiece('red', true,   { x: leftCenter.x - 40, y: leftCenter.y - 100 });
    createPiece('black', true, { x: leftCenter.x + 40, y: leftCenter.y - 100 });
  }

  // Snap toggle
  function setSnap(on){
    SNAP_ENABLED = !!on;
    snapToggle.setAttribute('aria-checked', on ? 'true' : 'false');
    snapDot.classList.toggle('off', !on);
  }

  // Controls
  standardBtn.addEventListener('click', standardSetup);
  emptyBtn.addEventListener('click', emptyBoard);
  resetBtn.addEventListener('click', initial);
  snapToggle.addEventListener('click', () => setSnap(!SNAP_ENABLED));
  snapToggle.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); setSnap(!SNAP_ENABLED); }
  });

  // Boot
  setSnap(true);
  initial();
})();
</script>
</body>
</html>
